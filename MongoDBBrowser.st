ComposableModel subclass: #MongoBrowserCoreViewer	instanceVariableNames: 'browserModel insideViewer mouseControllers arrowControllers text menuTop menuBottom statusBar'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-View'!!MongoBrowserCoreViewer commentStamp: 'KhrystynaMikhailuyk 2/6/2016 19:34' prior: 0!A MongoBrowser is a main window for MongoDB Browser.!!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/28/2017 22:19'!statusBar	^ statusBar! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 2/6/2016 19:40'!title	^ 'MongoDB Browser'! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/29/2017 21:52'!attributesDropDocuments: localViewer	| check |	localViewer selectedDocument		ifNil: [ UIManager inform: 'Please choose document' ]		ifNotNil: [ 			check := self browserModel dropDocument: localViewer.			check				ifNotNil: [ 					check						ifTrue: [ 														self inform: 'Document dropped' .							self refreshTab: localViewer.].												 ] ].				localViewer selectedDocument: nil.! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/12/2016 14:03'!attributesCreateDocument: localViewer	| check |	check := self browserModel createDocument: localViewer.	check		ifNotNil: [ 			check				ifTrue: [ 					self refreshView: localViewer.					self inform: 'Document created' ] ]! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 14:45'!handlesKeyboard:evt	"comment stating purpose of message"^true.! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 13:04'!browserModel	^ browserModel! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 13:04'!browserModel: anObject	browserModel := anObject! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/21/2017 14:44'!menuTop	^ menuTop! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/21/2017 14:44'!menuBottom	^ menuBottom! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/12/2016 18:58'!attributesDropDatabase: localViewer	| check |	localViewer selectedDatabase		ifNil: [ UIManager inform: 'Please choose database' ]		ifNotNil: [ 			check := self browserModel dropDBS: localViewer.			check				ifNotNil: [ 					check						ifTrue: [ 							self refreshView: localViewer.							self inform: 'Database dropped' ] ] ].				localViewer selectedDatabase: nil.! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/11/2016 21:18'!ensureKeyBindingsFor: aWidgetaWidget  := self.^super ensureKeyBindingsFor: aWidget.! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/21/2017 20:19'!showJson:localViewerlocalViewer browserState content tabManager selectedTab isNotNil ifTrue:[	Transcript clear;open.	MongoBrowserHelper formJson: localViewer browserState content tabManager selectedTab modelHolder.]ifFalse:[	self inform: 'Please select elements from collection' .	]! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/28/2017 21:27'!attributesListIndexes: localViewer	| model result |	localViewer selectedCollection isNil		ifTrue: [ UIManager inform: 'Please select collection' ]		ifFalse: [ result := self browserModel getIndexes: localViewer.			model := TreeModel new roots: result.			model := MongoBrowserHelper treeBranches: model.			self insideViewer browserState content				addTab: model				name: 'Indexes of ' , self insideViewer selectedCollection name ]! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/21/2017 14:44'!menuTop: anObject	menuTop := anObject! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/28/2017 21:49'!insert|result|result  := self browserModel insertDocuments: self insideViewer.	(result)		ifNil: [ ^ false.]		ifNotNil: [ 							UIManager inform: 'Document inserted'.				^ true.]! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/28/2017 21:50'!delete|result|result  := self browserModel deleteDocuments: self insideViewer.	(result)				ifNil: [ ^ false.]		ifNotNil: [ 					UIManager inform: 'Document(s) deleted'. 				^ true.]! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 4/22/2017 21:49'!updateDocuments: localViewer"	(self browserModel editDocument: self insideViewer)		ifNil: [ self insideViewer selectedCollection: nil ]		ifNotNil: [ self browserModel refresh: self insideViewer ]"			(self browserModel editDocument: self insideViewer)		ifNil: [ self insideViewer selectedCollection: nil ]		ifNotNil: [ self browserModel refresh: self insideViewer.			self insideViewer selectedCollection: nil ]! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/11/2016 23:48'!insideViewer	^ insideViewer! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/11/2016 23:48'!insideViewer: anObject	insideViewer := anObject! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/28/2017 22:19'!statusBar: anObject	statusBar := anObject! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 13:06'!addMouseController: aController      "controller := aController."	mouseControllers  add: aController.! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/12/2016 14:02'!attributesCreateCollection: localViewer	| check |	check := self browserModel createCollection: localViewer.	check		ifNotNil: [ 			check				ifTrue: [ 					self refreshView: localViewer.					self inform: 'Collection created' ] ]! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/12/2016 18:57'!attributesDropCollection: localViewer	| check |	localViewer selectedCollection		ifNil: [ UIManager inform: 'Please choose collection' ]		ifNotNil: [ 			check := self browserModel dropCollection: localViewer.			check				ifNotNil: [ 					check						ifTrue: [ 							self refreshView: localViewer.							self inform: 'Collection dropped' ] ] ].				localViewer selectedCollection: nil.! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/21/2017 21:01'!attributesCreateIndex: localViewer	| indexName |	localViewer selectedCollection isNil		ifTrue: [ UIManager inform: 'Please select collection' ]		ifFalse: [ indexName := UIManager default request: 'Index name'.			indexName isNotNil				ifTrue: [					self browserModel createIndex: indexName viewer: localViewer.					self refreshView: localViewer.					self inform: 'Index created' ] ]! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/19/2017 12:17'!attributesCreateDatabase: localViewer	| check |	check := self browserModel createDBS: localViewer windowCreation createModel.	check		ifNotNil: [ 			check				ifTrue: [ 					self refreshView: localViewer.					self inform: 'Database created' ] ]! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/30/2017 22:23'!select|result model aCollection version|aCollection  :=self insideViewer selectedCollection name.result := self browserModel selectDocuments: self insideViewer.	(result)		ifNil: [ "self insideViewer selectedCollection: nil. "^false.]		ifNotNil: [ 					 model := TreeModel new				roots: (result collect: [ :each | each asMyDictionary ]).			model := MongoBrowserHelper treeBranches: model.			"self insideViewer content addTab: model."			version := self insideViewer browserState content addTab: model name: 'Select from ', aCollection fromCollection: result.							statusBar text: 'VERSION  ' asText, version  asString, ' select from ', aCollection, '   count of elements: ', result size asString.													"(MongoDBContentList new						items: (result collect: [ :each | each asMyDictionary ]);						treeBranches) openWithSpec."								"self browserModel refresh: self insideViewer.			self insideViewer selectedCollection: nil. "			^true.]! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/30/2017 22:45'!clearStatusBar	statusBar text: ''.! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 13:08'!addArrowController: aController      "controller := aController."	arrowControllers  add: aController.! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/11/2016 21:39'!bindKeyCombination: aShortcut toAction: aBlock	super bindKeyCombination: aShortcut toAction: aBlock.		arrowControllers onKeyPressed: $d.! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/21/2017 14:44'!arrowControllers	^ arrowControllers! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 4/23/2017 13:52'!deleteDocumentsself insideViewer selectedCollection isNil		ifFalse: [ 			self insideViewer windowDelete openWithSpec.]			ifTrue: [ 			UIManager inform: 'Please select collection'.			^ false ].! !!MongoBrowserCoreViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/21/2017 14:44'!menuBottom: anObject	menuBottom := anObject! !!MongoBrowserCoreViewer methodsFor: 'initialization' stamp: 'KhrystynaMykhailiuk 5/31/2017 01:17'!selectAll: aCollection	| model version|	aCollection		ifNotNil: [ model := TreeModel new				roots: ((aCollection select: MyDictionary new) collect: [ :each | each asMyDictionary ]).			model := MongoBrowserHelper treeBranches: model.			"self insideViewer content addTab: model."			version := self insideViewer browserState content addTab: model name: aCollection qualifiedName fromCollection: aCollection.			statusBar text: 'VERSION  ',version asString ,' ' , aCollection qualifiedName, '   count of elements: ', aCollection size asString]		ifNil: [ UIManager inform:'Please select collection.' ]! !!MongoBrowserCoreViewer methodsFor: 'initialization' stamp: 'KhrystynaMikhailuyk 5/3/2016 21:45'!initializePresenter	"viewer whenDatabaseChanged: [ :class | text behavior: class ]."	"viewer whenProtocolChangedDo: [ :item | 		item 			ifNil: [ text text: '' ]			ifNotNil: [ text text: item sourceCode ] ].	viewer whenEventChangedDo: [ :item | 		item 			ifNil: [ text text: '' ]			ifNotNil: [ text text: item sourceCode ] ]"! !!MongoBrowserCoreViewer methodsFor: 'initialization' stamp: 'KhrystynaMikhailuyk 5/9/2016 14:41'!notifyControllers: aChararrowControllers do:[:controller|	controller onKeyPressed: aChar.].! !!MongoBrowserCoreViewer methodsFor: 'initialization' stamp: 'KhrystynaMikhailuyk 5/9/2016 15:07'!keyStrokesForNextFocus:aKeyboardEvent	|c|		c := aKeyboardEvent keyCharacter.	self notifyControllers: c.! !!MongoBrowserCoreViewer methodsFor: 'initialization' stamp: 'KhrystynaMykhailiuk 2/4/2018 19:01'!initializeWidgets	text := self newText.	mouseControllers := Set new.	browserModel := MongoBrowserCoreModel new.	insideViewer := self instantiate: MongoBrowserViewer new.	insideViewer owner: self.	arrowControllers := KeyboardControllers new.	statusBar := TextModel new enabled: false.	text aboutToStyle: true.	self initializeTopMenu.	"menu applyTo: self.	text := self newText."	self bindKeyCombination: $d toAction: [ self menuDelete: self ].	self bindKeyCombination: $c toAction: [ self menuCreate: self insideViewer ].	self bindKeyCombination: $r toAction: [ self refresh ].	self bindKeyCombination: $s toAction: [ self selectAll: self insideViewer selectedCollection].	self bindKeyCombination: $j toAction: [ self showJson: self insideViewer].	self bindKeyCombination: $i toAction: [ self insert. ].	self bindKeyCombination: $u toAction: [ self update. ].		self focusOrder		add: text;		add: insideViewer;		add: text! !!MongoBrowserCoreViewer methodsFor: 'initialization' stamp: 'KhrystynaMykhailiuk 5/11/2016 21:17'!registerKeyStrokesForNextFor: aWidget	^ super registerKeyStrokesForNextFor: aWidget! !!MongoBrowserCoreViewer methodsFor: 'initialization' stamp: 'KhrystynaMykhailiuk 5/11/2016 21:17'!registerKeyStrokesForPreviousFor: aWidget	^ super registerKeyStrokesForPreviousFor: aWidget! !!MongoBrowserCoreViewer methodsFor: 'initialization' stamp: 'KhrystynaMykhailiuk 5/21/2017 13:59'!initialExtent	^ 900@600! !!MongoBrowserCoreViewer methodsFor: 'initialization' stamp: 'KhrystynaMykhailiuk 5/28/2017 21:10'!initializeTopMenu	| model |	menuTop := MenuModel new		addGroup: [ :group | 			group				addItem: [ :item | 					item						name: 'Create';						icon: Smalltalk ui icons smallAddIcon;						subMenu: (self subMenuCreate: self insideViewer) ].			group				addItem: [ :item | 					item						name: 'Drop';						icon: Smalltalk ui icons smallDeleteIcon;						subMenu: (self subMenuDelete: self insideViewer) ] ];				addGroup: [:group | 					group				addItem: [ :item | 					item						name: 'Load data';						icon: Smalltalk ui icons mongoDocumentIcon;						action: [ self selectAll: self insideViewer selectedCollection ] ].					group				addItem: [ :item | 					item						name: 'Refresh';						icon: Smalltalk ui icons smallUpdateIcon;						action: [ self refresh ] ].			group				addItem: [ :item | 					item						name: 'As Json';						icon: Smalltalk ui icons collection;						action: [ self showJson: self insideViewer] ].			];		addGroup: [ :group | 						group				addItem: [ :item | 					item						name: 'CRUD';						icon: Smalltalk ui icons image;						subMenu: (self subMenuManage: self insideViewer) ].			group				addItem: [ :item | 					item						name: 'Index';						icon: Smalltalk ui icons processBrowser;						subMenu: (self subMenuIndex: self insideViewer) ].			 ];		addGroup: [ :group | 			group				addItem: [ :item | 					item						name: 'About';						icon: Smalltalk ui icons smallInfoIcon;						action: [ model := TextModel new								text:									'MongoDBBrowser created and designed byKhrystyna Mykhailiuk & Viktoriya Yuriyak.';								enabled: false.							self insideViewer browserState content addTab: model name: 'About' ] ].			group				addItem: [ :item | 					item						name: 'Help';						icon: Smalltalk ui icons smallHelpIcon;						action: [ model := TextModel new								text: self browserModel help;								enabled: false.							self insideViewer browserState content addTab: model name: 'Help' ] ].			group				addItem: [ :item | 					item						name: 'Exit';						icon: Smalltalk ui icons smallCancelIcon;						action: [ self exitPopap								ifTrue: [ super delete.									self inform: 'MongoDBBrowser was closed' ] ] ] ]! !!MongoBrowserCoreViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/14/2017 19:43'!refreshself browserModel refresh: self insideViewer.self inform: 'Databases refreshed'.self insideViewer content removeAllTabs.! !!MongoBrowserCoreViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/19/2017 22:54'!openWindowCreation: localViewer	(localViewer windowCreation)		makeWindowState: localViewer;		openWithSpec! !!MongoBrowserCoreViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:49'!refreshView: localViewerself browserModel refresh:localViewer ."self setEmptyVisualContent: localViewer.localViewer databases getBaseList."self browserModel viewer: (self instantiate: MongoBrowserViewer ).self defaultSpec .! !!MongoBrowserCoreViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/12/2016 13:24'!subMenuDelete: localViewer	^ MenuModel new		addGroup: [ :group | 			group				addItem: [ :item | 					item						name: 'Drop database';						icon: Smalltalk ui icons smallDeleteIcon;						action: [ self attributesDropDatabase: localViewer ] ].			group				addItem: [ :item | 					item						name: 'Drop collection';						icon: Smalltalk ui icons smallDeleteIcon;						action: [ self attributesDropCollection: localViewer ] ].			group				addItem: [ :item | 					item						name: 'Drop document';						icon: Smalltalk ui icons smallDeleteIcon;						action: [ self attributesDropDocuments: localViewer ] ] ]! !!MongoBrowserCoreViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/19/2017 11:05'!exitPopap	"popap for exit question "		 ^ UIManager default question: 'Are you sure you want to exit?' title: 'Exit question'.											! !!MongoBrowserCoreViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/28/2017 21:54'!subMenuManage: localViewer	^ MenuModel new		addGroup: [ :group | 		group				addItem: [ :item | 					item						name: 'Query';						icon: Smalltalk ui icons smallFindIcon;						action: [ self select.] ].					group				addItem: [ :item | 					item						name: 'Insert';						icon: Smalltalk ui icons smallLoadProject;						action: [ self insert.] ].				group				addItem: [ :item | 					item						name: 'Update';						icon: Smalltalk ui icons smallCopy;						action: [ self update. ] ].			group				addItem: [ :item | 					item						name: 'Delete';						icon: Smalltalk ui icons smallSelectIcon;						action: [ self delete.] ].						]			! !!MongoBrowserCoreViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/31/2017 01:12'!menuCreate: localViewer	| res |	res := UIManager default chooseFrom: #('Database' 'Collection') values: #(1 2) title: 'Create'.	res = 1		ifTrue: [ localViewer windowCreation openWithSpec.]		ifFalse: [ 			res = 2				ifTrue: [ self attributesCreateCollection: localViewer]]! !!MongoBrowserCoreViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:24'!openWindowDelete: localViewer	(localViewer windowDelete)		"makeWindowState: localViewer;"		openWithSpec! !!MongoBrowserCoreViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 2/6/2016 19:39'!text	^ text! !!MongoBrowserCoreViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 2/18/2016 11:48'!menu   ^menu! !!MongoBrowserCoreViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/29/2017 21:57'!update|result|result  := self browserModel updateDocuments: self insideViewer.	(result)		ifNil: [ ^ false.]		ifNotNil: [ 					UIManager inform: 'Document updated'.							^ true.]! !!MongoBrowserCoreViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/31/2017 01:17'!refreshTab: localViewer	| tabManager model tabsOfOneCollection tab|	tabManager := localViewer browserState content tabManager.	tabsOfOneCollection := (tabManager tabs) select:[:each| each label = localViewer selectedCollectionName ].			tab := (tabsOfOneCollection select:[:each| each version = localViewer selectedTabVersion ]) at: 1.					model := TreeModel new						roots:							(( tab relatedCollection select: MyDictionary new) collect: [ :each | each asMyDictionary ]).					model := MongoBrowserHelper treeBranches: model.					tab model: model.					"self insideViewer content addTab: model."					"self insideViewer browserState content						addTab: model						name: localViewer selectedCollectionName						fromCollection: tempTab relatedCollection."			! !!MongoBrowserCoreViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/12/2016 18:18'!menuDelete: localViewer	| res |	res := UIManager default chooseFrom: #('Database' 'Collection' 'Document') values: #(1 2 3) title: 'Drop'.	res = 1		ifTrue: [ self attributesDropDatabase: localViewer insideViewer ]		ifFalse: [ 			res = 2				ifTrue: [ self attributesDropCollection: localViewer insideViewer]				ifFalse: [ 					res = 3						ifTrue: [ self attributesDropDocuments: localViewer insideViewer ] ] ]! !!MongoBrowserCoreViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/28/2017 21:21'!subMenuIndex: localViewer	^ MenuModel new		addGroup: [ :group | 			group				addItem: [ :item | 					item						name: 'Create index';						icon: Smalltalk ui icons smallAddIcon;						action: [ self attributesCreateIndex: localViewer.] ].								group				addItem: [ :item | 					item						name: 'Show indexes';						icon: Smalltalk ui icons glamorousThrough ;						action: [ self attributesListIndexes: localViewer.] ].			]			! !!MongoBrowserCoreViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/28/2017 20:58'!subMenuCreate: localViewer	^ MenuModel new		addGroup: [ :group | 			group				addItem: [ :item | 					item						name: 'Create database';						icon: Smalltalk ui icons smallAddIcon;						action: [ 									localViewer windowCreation openWithSpec.] ];				addItem: [ :item | 					item						name: 'Create collection';						icon: Smalltalk ui icons smallAddIcon;						action: [ 									self attributesCreateCollection: localViewer.] ].			]			! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MongoBrowserCoreViewer class	instanceVariableNames: ''!!MongoBrowserCoreViewer class methodsFor: 'spec' stamp: 'KhrystynaMykhailiuk 5/28/2017 22:50'!defaultSpec	<spec: #default>		^ SpecLayout composed				newColumn: [ : c1 |				c1 add:(#menuTop)height: 38;				add:#statusBar height: 38;								newRow: [ :row |					row 					add: #(insideViewer databases) origin: 0@1 corner: 0.5@0 offsetOrigin: 1@1 offsetCorner: 200@200;									newColumn: [ :column1 |					column1 					"add:#(viewer collections) origin: 0.5@0.5 corner: 1@0 offsetOrigin: 1@1 offsetCorner: 100@200;					add:#(viewer content) origin: 0.5@0.5 corner: 1@0 offsetOrigin: 1@1 offsetCorner: 100@300 "					"add:#(insideViewer collections) ;"					add:#(insideViewer content)height:486] 				]];									yourself 																! !ComposableModel subclass: #MongoBrowserPopupWindow	instanceVariableNames: 'okButton cancelButton mainViewer model equalSymbol'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-View'!!MongoBrowserPopupWindow methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/26/2017 19:21'!initializeWidgets! !!MongoBrowserPopupWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 17:10'!equalSymbol	"| symbol |	symbol := LabelModel new.	symbol text: '='.	^ symbol"	^ LabelModel new text: ' = '! !!MongoBrowserPopupWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/22/2017 12:16'!mainViewer	^ mainViewer! !!MongoBrowserPopupWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 19:16'!cancelButton: anObject	cancelButton := anObject! !!MongoBrowserPopupWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/22/2017 12:16'!mainViewer: anObject	mainViewer := anObject! !!MongoBrowserPopupWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/22/2017 12:16'!model	^ model! !!MongoBrowserPopupWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/22/2017 12:16'!model: anObject	model := anObject! !!MongoBrowserPopupWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 19:16'!cancelButton	^ cancelButton! !!MongoBrowserPopupWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 19:16'!okButton: anObject	okButton := anObject! !!MongoBrowserPopupWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 17:07'!equalSymbol: anObject	equalSymbol := anObject! !!MongoBrowserPopupWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 19:16'!okButton	^ okButton! !!MongoBrowserPopupWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 4/23/2017 12:01'!cancelButtonAction|result|			result := UIManager default question: 'Are you sure you want to exit?' title: 'Question'.			result == true & (result ~= nil)				ifTrue: [ super delete ] ! !MongoBrowserPopupWindow subclass: #MongoBrowserCreateWindow	instanceVariableNames: 'labelDatabase labelCollection labelDocument databaseTextBox collectionTextBox documentTextField createModel'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-View'!!MongoBrowserCreateWindow methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 4/23/2017 12:23'!initializePresenter	|  |	databaseTextBox whenTextChanged: [ self createModel databaseName: databaseTextBox text ].	collectionTextBox whenTextChanged: [ self createModel collectionName: collectionTextBox text ].	documentTextField whenTextChanged: [ self createModel documentScript: documentTextField text ].	cancelButton		action: [  super cancelButtonAction.			self clearFields.].	okButton		action: [ 			self okButtonAction				ifTrue: [ 					self okButtonAction.					self mainViewer owner attributesCreateDatabase: self mainViewer.					self delete.					self clearFields. ] ]! !!MongoBrowserCreateWindow methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:46'!initialExtent	^ 400@300! !!MongoBrowserCreateWindow methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/18/2017 20:14'!title	^ 'CREATE'! !!MongoBrowserCreateWindow methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/4/2018 20:27'!initializeWidgets	"	self		instantiateModels:			#(#databaseTextBox #TextInputFieldModel #collectionTextBox #TextInputFieldModel #documentTextField #TextInputFieldModel  #okButton #ButtonModel #cancelButton #ButtonModel)."	labelDatabase := LabelModel new label: 'Database name'.	labelCollection := LabelModel new label: 'Collection name'.	labelDocument := LabelModel new label: 'Query for document'.	databaseTextBox := TextInputFieldModel new text: ' '; autoAccept: true.	collectionTextBox := TextInputFieldModel new text: ' '; autoAccept: true.	documentTextField := TextInputFieldModel new text: ' ';autoAccept: true.	okButton := ButtonModel new label: 'OK'.	cancelButton := ButtonModel new label: 'Cancel'.	createModel := MongoBrowserCreateWindowModel new! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/18/2017 16:52'!documentTextField	^ documentTextField! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 4/23/2017 12:22'!clearFields	self databaseTextBox text: ' '.	self collectionTextBox text: ' '.	self documentTextField text: ' '! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/18/2017 16:52'!collectionTextBox: anObject	collectionTextBox := anObject! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/18/2017 16:52'!labelDatabase	^ labelDatabase! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/18/2017 16:52'!collectionTextBox	^ collectionTextBox! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/18/2017 16:52'!labelDocument: anObject	labelDocument := anObject! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/18/2017 16:52'!labelCollection: anObject	labelCollection := anObject! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/18/2017 16:52'!databaseTextBox	^ databaseTextBox! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/18/2017 16:52'!databaseTextBox: anObject	databaseTextBox := anObject! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/19/2017 23:10'!makeWindowState: viewer	viewer selectedDatabase		ifNotNil: [ 			databaseTextBox				text: viewer selectedDatabase;				disable ].	viewer selectedCollection		ifNotNil: [ 			collectionTextBox				text: viewer selectedCollection;				disable ].	^ self! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/19/2017 11:36'!createModel	^ createModel! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/18/2017 16:52'!labelDatabase: anObject	labelDatabase := anObject! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/19/2017 11:36'!mainViewer: anObject	mainViewer := anObject! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/18/2017 16:52'!labelDocument	^ labelDocument! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 4/23/2017 12:40'!isValid: windowModel	(windowModel databaseName = ' ' or:[windowModel databaseName isNil])ifTrue:[			UIManager inform: 'You need to fill database and collection names '.			^ false.		]	ifFalse:[		(windowModel collectionName = ' ' or: [ windowModel collectionName ='' ])		ifTrue:[			UIManager inform: 'You need to fill database and collection names '.			^ false.			]		].		^ true! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 4/23/2017 12:30'!okButtonAction	(self isValid: self createModel)		ifTrue: [ 			self createModel databaseName: self databaseTextBox text capitalized.			self createModel collectionName: self collectionTextBox text capitalized.			self createModel documentScript: self documentTextField text capitalized.			^ true ].			^ false! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/19/2017 11:36'!mainViewer	^ mainViewer! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/18/2017 16:52'!documentTextField: anObject	documentTextField := anObject! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/19/2017 11:36'!createModel: anObject	createModel := anObject! !!MongoBrowserCreateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/18/2017 16:52'!labelCollection	^ labelCollection! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MongoBrowserCreateWindow class	instanceVariableNames: ''!!MongoBrowserCreateWindow class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:45'!defaultSpec	^ (SpecLayout composed)		newColumn: [ :mainColumn | 					mainColumn						newRow: [ :rowDatabase | 							rowDatabase								add: #labelDatabase;								add: #databaseTextBox width: 250 ]						height: 25;											newRow: [ :rowCollection | 							rowCollection								add: #labelCollection;								add: #collectionTextBox width: 250 ]						height: 28;						newRow: [ :rowDocument | 							rowDocument newColumn: [ :buttonColumn | buttonColumn newRow: [ :rowButton | rowButton add: #labelDocument ] ].							rowDocument								newColumn: [ :buttonColumn | buttonColumn newRow: [ :rowButton | rowButton add: #documentTextField ] ]								width: 250 ];						newRow: [ :row | 									row										newColumn: [ :c |  ] left: 0 right: 0.6;										newColumn: [ :c | 													c														newRow: [ :inRow | 															inRow																add: #okButton;																add: #cancelButton ] ]											left: 0.4											right: 0 ]							height: 30];		yourself	"Adding Main column"! !MongoBrowserPopupWindow subclass: #MongoBrowserDeleteWindow	instanceVariableNames: 'labelDelete fieldTextBox valueTextBox deleteModel'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-View'!!MongoBrowserDeleteWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/22/2017 12:23'!deleteModel: anObject	deleteModel := anObject! !!MongoBrowserDeleteWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 17:14'!labelDelete	^ LabelModel new text: '               Delete documents where: '! !!MongoBrowserDeleteWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/22/2017 12:23'!fieldTextBox	^ fieldTextBox! !!MongoBrowserDeleteWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/22/2017 12:23'!fieldTextBox: anObject	fieldTextBox := anObject! !!MongoBrowserDeleteWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/22/2017 12:23'!labelDelete: anObject	labelDelete := anObject! !!MongoBrowserDeleteWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 19:50'!okButtonAction(self isValid: self deleteModel)		ifTrue: [  ^true ].^false.! !!MongoBrowserDeleteWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/22/2017 12:23'!valueTextBox: anObject	valueTextBox := anObject! !!MongoBrowserDeleteWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/22/2017 12:23'!deleteModel	^ deleteModel! !!MongoBrowserDeleteWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 19:50'!isValid: windowModel	(windowModel withField = nil or: [ windowModel withValue = nil])		ifTrue: [ 			UIManager inform: 'You need to fill all fields'.			^ false ].	^ true! !!MongoBrowserDeleteWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/22/2017 12:23'!valueTextBox	^ valueTextBox! !!MongoBrowserDeleteWindow methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/26/2017 19:51'!initializePresenter	fieldTextBox whenTextChanged: [ self deleteModel withField:  fieldTextBox text ].	valueTextBox whenTextChanged: [ self deleteModel withValue:  valueTextBox text ].	cancelButton action: [ self cancelButtonAction ].	okButton		action: [ 			self okButtonAction				ifTrue: [ 			(self mainViewer owner browserModel deleteDocuments: self mainViewer data: self deleteModel )				ifNil: [ self mainViewer selectedCollection: nil ]				ifNotNil: [ "self browserModel refresh: self insideViewer" ].			self delete ]		ifFalse:[] ]! !!MongoBrowserDeleteWindow methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:41'!initialExtent	^ 300@180! !!MongoBrowserDeleteWindow methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/4/2018 20:29'!initializeWidgets	fieldTextBox := TextInputFieldModel new text: ' '.	valueTextBox := TextInputFieldModel new text: ' '.	okButton := ButtonModel new label: 'OK'.	cancelButton := ButtonModel new label: 'Cancel'.	deleteModel := MongoBrowserDeleteWindowModel new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MongoBrowserDeleteWindow class	instanceVariableNames: ''!!MongoBrowserDeleteWindow class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/26/2017 17:59'!defaultSpec	^ (SpecLayout composed)		newColumn: [ :mainColumn | 					mainColumn						newRow: [ :rowDatabase | rowDatabase add: #labelDelete ] height: 40;						newRow: [ :rowCollection | 									rowCollection										add: #fieldTextBox width: 125;										add: #equalSymbol width: 35;										add: #valueTextBox width: 140 ]							height: 35;						newRow: [ :row | 									row										newColumn: [ :c |  ] left: 0 right: 0.7;										newColumn: [ :c | 													c														newRow: [ :inRow | 															inRow																add: #okButton;																add: #cancelButton ] ]											left: 0.3											right: 0 ]							height: 30 ];		yourself! !ComposableModel subclass: #MongoBrowserSubWindow	instanceVariableNames: 'labelGreeting textName buttonGreet radioMr radioMrs radioMs table'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-View'!!MongoBrowserSubWindow methodsFor: 'initialization' stamp: 'KhrystynaMykhailiuk 2/11/2017 17:19'!initializePresenter        textName whenTextChanged: [                 buttonGreet enable ].        buttonGreet action: [                 labelGreeting text: 'Hello, ', self userTitle, ' ', textName text, '!!'.                buttonGreet disable ].! !!MongoBrowserSubWindow methodsFor: 'initialization' stamp: 'KhrystynaMykhailiuk 2/11/2017 16:57'!initialExtent	^ 750@600! !!MongoBrowserSubWindow methodsFor: 'initialization' stamp: 'KhrystynaMykhailiuk 2/11/2017 17:19'!userTitle        "Find out user's title by checking the radio buttons."                radioMr state                ifTrue: [ ^ radioMr label ]                ifFalse: [                         radioMrs state                                ifTrue: [ ^ radioMrs label ]                                 ifFalse: [ ^ radioMs label ] ].! !!MongoBrowserSubWindow methodsFor: 'initialization' stamp: 'KhrystynaMykhailiuk 2/18/2017 21:43'!initializeWidgetsself instantiateModels: #(                labelGreeting   LabelModel                 buttonGreet     ButtonModel                radioMr         RadioButtonModel                 radioMs         RadioButtonModel                 radioMrs        RadioButtonModel         ).	textName  := StringMorph new;asSpecAdapter .        labelGreeting text: ''.        textName autoAccept: true.        buttonGreet label: 'Greet Me!!'; disable.        self setupTitleRadioButtons.        "table simpleExample."! !!MongoBrowserSubWindow methodsFor: 'initialization' stamp: 'KhrystynaMykhailiuk 2/11/2017 17:17'!setupTitleRadioButtons        radioMr label: 'Mr.'.        radioMs label: 'Ms.'.        radioMrs label: 'Mrs.'.                RadioButtonGroup new                addRadioButton: radioMr;                addRadioButton: radioMs;                addRadioButton: radioMrs;                default: radioMr.! !!MongoBrowserSubWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/11/2017 17:29'!radioMs	^ radioMs! !!MongoBrowserSubWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/11/2017 17:29'!radioMr	^ radioMr! !!MongoBrowserSubWindow methodsFor: 'accessing' stamp: 'Anonymous 2/16/2017 00:52'!table	^ table! !!MongoBrowserSubWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/11/2017 17:29'!radioMrs	^ radioMrs! !!MongoBrowserSubWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/11/2017 17:29'!labelGreeting: anObject	labelGreeting := anObject! !!MongoBrowserSubWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/11/2017 17:29'!labelGreeting	^ labelGreeting! !!MongoBrowserSubWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/11/2017 17:29'!textName: anObject	textName := anObject! !!MongoBrowserSubWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/11/2017 17:29'!textName	^ textName! !!MongoBrowserSubWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/11/2017 17:29'!buttonGreet: anObject	buttonGreet := anObject! !!MongoBrowserSubWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/11/2017 17:29'!buttonGreet	^ buttonGreet! !!MongoBrowserSubWindow methodsFor: 'accessing' stamp: 'Anonymous 2/16/2017 00:52'!table: anObject	table := anObject! !!MongoBrowserSubWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/11/2017 17:29'!radioMs: anObject	radioMs := anObject! !!MongoBrowserSubWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/11/2017 17:29'!radioMrs: anObject	radioMrs := anObject! !!MongoBrowserSubWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/11/2017 17:29'!radioMr: anObject	radioMr := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MongoBrowserSubWindow class	instanceVariableNames: ''!!MongoBrowserSubWindow class methodsFor: 'spec' stamp: 'KhrystynaMykhailiuk 2/18/2017 19:53'!defaultSpec^ SpecColumnLayout new                        add: #labelGreeting;                        add: #textName;                        add: #buttonGreet;                        add: #radioMr;                        add: #radioMrs;                        add: #radioMs                        yourself.! !MongoBrowserPopupWindow subclass: #MongoBrowserUpdateWindow	instanceVariableNames: 'fieldTextBoxWith valueTextBoxWith fieldTextBoxWhere valueTextBoxWhere updateModel'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-View'!!MongoBrowserUpdateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:35'!labelUpdateEnd^ LabelModel new text:'             where:'! !!MongoBrowserUpdateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:34'!labelUpdateStart^ LabelModel new text:'             Update documents with:'! !!MongoBrowserUpdateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:35'!valueTextBoxWith: anObject	valueTextBoxWith := anObject! !!MongoBrowserUpdateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:37'!initializePresenter"	| result |	fieldTextBox whenTextChanged: [ self createModel databaseName: fieldTextBox  text ].	valueTextBox  whenTextChanged: [ self createModel collectionName: valueTextBox text ]..	cancelButton		action: [ 			result := UIManager default question: 'Are you sure you wan to exit?' title: 'Question'.			result == true & (result ~= nil)				ifTrue: [ super delete ] ].	okButton		action: [ 			self okButtonAction				ifTrue: [ 					self mainViewer owner attributesCreateDatabase: self mainViewer.					self delete ] ]"! !!MongoBrowserUpdateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:35'!updateModel	^ updateModel! !!MongoBrowserUpdateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:35'!valueTextBoxWhere: anObject	valueTextBoxWhere := anObject! !!MongoBrowserUpdateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:35'!fieldTextBoxWith	^ fieldTextBoxWith! !!MongoBrowserUpdateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 19:17'!initializeWidgets	fieldTextBoxWith := TextInputFieldModel new text: ' '.	valueTextBoxWith := TextInputFieldModel new text: ' '.	fieldTextBoxWhere := TextInputFieldModel new text: ' '.	valueTextBoxWhere := TextInputFieldModel new text: ' '.	okButton := ButtonModel new label: 'OK'.	cancelButton := ButtonModel new label: 'Cancel'! !!MongoBrowserUpdateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:35'!valueTextBoxWith	^ valueTextBoxWith! !!MongoBrowserUpdateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:35'!fieldTextBoxWhere: anObject	fieldTextBoxWhere := anObject! !!MongoBrowserUpdateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:35'!fieldTextBoxWith: anObject	fieldTextBoxWith := anObject! !!MongoBrowserUpdateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:35'!fieldTextBoxWhere	^ fieldTextBoxWhere! !!MongoBrowserUpdateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:35'!updateModel: anObject	updateModel := anObject! !!MongoBrowserUpdateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:35'!valueTextBoxWhere	^ valueTextBoxWhere! !!MongoBrowserUpdateWindow methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:40'!initialExtent	^ 300@250! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MongoBrowserUpdateWindow class	instanceVariableNames: ''!!MongoBrowserUpdateWindow class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:39'!defaultSpec	^ (SpecLayout composed)		newColumn: [ :mainColumn | 					mainColumn						newRow: [ :rowDatabase | rowDatabase add: #labelUpdateStart ] height: 40;						newRow: [ :rowCollection | 									rowCollection										add: #fieldTextBoxWith width: 125;										add: #equalSymbol width: 35;										add: #valueTextBoxWith width: 140 ]							height: 35;						newRow: [ :rowDatabase | rowDatabase add: #labelUpdateEnd ] height: 40;						newRow: [ :rowCollection | 									rowCollection										add: #fieldTextBoxWhere width: 125;										add: #equalSymbol width: 35;										add: #valueTextBoxWhere width: 140 ]							height: 35;						newRow: [ :row | 									row										newColumn: [ :c |  ] left: 0 right: 0.7;										newColumn: [ :c | 													c														newRow: [ :inRow | 															inRow																add: #okButton;																add: #cancelButton ] ]											left: 0.3											right: 0 ]							height: 30 ];		yourself! !ComposableModel subclass: #MongoBrowserViewer	instanceVariableNames: 'browserState databases collections content selectedCollection selectedCollectionName selectedDatabase selectedDocument windowCreation windowDelete windowUpdate selectedTabVersion'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-View'!!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:31'!windowUpdate: anObject	windowUpdate := anObject! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:59'!collections	^ browserState collections! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/3/2016 21:46'!selectedDocument	^ selectedDocument! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/3/2016 21:46'!selectedDatabase	^ selectedDatabase! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:52'!browserState	^ browserState! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/21/2017 19:01'!selectedCollectionName: anObject	selectedCollectionName := anObject! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/3/2016 21:46'!selectedDatabase: anObject	selectedDatabase := anObject! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:59'!databases: anObject	browserState databases: anObject.! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/21/2017 19:01'!selectedCollectionName	^ selectedCollectionName! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/19/2017 11:56'!windowCreation	^ windowCreation! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/30/2017 23:20'!selectedTabVersion: anObject	selectedTabVersion := anObject! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:59'!collections: database 	^ (browserState database collections).! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/3/2016 21:46'!selectedDocument: anObject	selectedDocument := anObject! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:59'!databases	^ browserState databases! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/30/2017 23:20'!selectedTabVersion	^ selectedTabVersion! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:31'!windowDelete: anObject	windowDelete := anObject! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:31'!windowUpdate	^ windowUpdate! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/3/2016 12:04'!selectedCollection	^ selectedCollection! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/19/2017 11:56'!windowCreation: anObject	windowCreation := anObject! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:52'!browserState: anObject	browserState := anObject! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:59'!content	^ browserState content! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 12:00'!content: anObject	browserState content: anObject! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/3/2016 12:04'!selectedCollection: anObject	selectedCollection := anObject! !!MongoBrowserViewer methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 18:31'!windowDelete	^ windowDelete! !!MongoBrowserViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/11/2016 19:45'!title	^ ''! !!MongoBrowserViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/8/2016 20:49'!selectAllIdInDictionary: collection|collIds|collIds :=  Dictionary  new.	collection		do: [ :diction | 						diction				associationsDo: [ :assoc | 					assoc key asString = '_id'						ifTrue: [ 							collIds at: (assoc value asString) put: diction. ] ] ].				^collIds.! !!MongoBrowserViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:52'!whenColectionChangedDo: aBlock	browserState collections whenSelectedItemChanged: aBlock! !!MongoBrowserViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/21/2017 20:48'!initializePresenter	self selectedDatabase: nil.	self selectedCollection: nil.		browserState databases		whenSelectedItemChanged: [ :item | 			item 				ifNil: [ "browserState collections items: #()."					self selectedDatabase: nil.					self selectedCollection: nil.]				ifNotNil: [ item  isMongoDatabase						ifTrue: [ 							"Transcript show: database name."					self selectedDatabase: item.							"browserState content items: (browserState collectionsIn: database) "]						ifFalse: [ 										self selectedDatabase: item database.											self selectedCollection:  item.							] ].			"Transcript show:database isMongoDatabase ."			"browserState content items: #()."						]! !!MongoBrowserViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/8/2016 21:54'!rewriteCollectionOfDictionaries: collection|collIds tempDict|collIds :=  OrderedCollection  new.	collection		do: [ :diction | 						diction				associationsDo: [ :assoc | 					assoc key asString = '_id'						ifTrue: [ tempDict := Dictionary new.							        tempDict  at: (assoc value asString) put: diction.							collIds add:tempDict  . ] ] ].				^collIds.! !!MongoBrowserViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/14/2017 13:02'!initializeWidgets   self browserState: MongoBrowserState new.	databases := self instantiate: MongoDatabasesList.		content := self instantiate: TabsDynamicArea.				"content owner: self."	windowCreation := MongoBrowserCreateWindow new.	windowCreation mainViewer: self.	"windowDelete := MongoBrowserDeleteWindow new title:'DELETE'.	windowDelete  mainViewer: self."		self browserState databases: (self instantiate: MongoDatabasesList).	self browserState content: (self instantiate: TabsDynamicArea).		self selectedDatabase: nil.		self focusOrder 		add: databases;		add: content! !!MongoBrowserViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:53'!whenContentChangedDo: aBlock	browserState content whenSelectedItemChanged: aBlock! !!MongoBrowserViewer methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 4/1/2017 21:32'!whenDatabaseChanged: aBlock	"browserState databases whenSelectedItemChanged: aBlock"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MongoBrowserViewer class	instanceVariableNames: ''!!MongoBrowserViewer class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/14/2017 13:00'!defaultSpec	<spec: #default>		^ SpecLayout composed		newColumn: [ :column |			column 							add: #databases; 				add: #content];		yourself! !ComposableModel subclass: #MongoDBContentList	instanceVariableNames: 'label collectionsList rootItems'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-View'!!MongoDBContentList methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/8/2016 19:44'!rootItems	^ rootItems! !!MongoDBContentList methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/8/2016 20:25'!collectionsList	^ collectionsList! !!MongoDBContentList methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/8/2016 19:44'!rootItems: anObject	rootItems := anObject! !!MongoDBContentList methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/11/2016 19:46'!label1: anObject	label := anObject! !!MongoDBContentList methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/8/2016 20:25'!collectionsList: anObject	collectionsList := anObject! !!MongoDBContentList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 4/1/2017 21:31'!whenSelectedItemChanged: aBlock	collectionsList whenSelectedItemChanged: aBlock! !!MongoDBContentList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/8/2016 20:24'!resetSelection	collectionsList resetSelection! !!MongoDBContentList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/8/2016 21:55'!selectAllKeysFromCollection: collection |collIds|collIds :=  OrderedCollection   new.	collection		do: [ :diction | 						diction				associationsDo: [ :assoc | 					assoc key asString = '_id'						ifTrue: [ 							collIds add: (assoc value asString). ] ] ].				^collIds.! !!MongoDBContentList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/2/2017 15:38'!treeBranches	collectionsList		ifNil: [ ^ nil ]		ifNotNil: [ 			collectionsList hasChildrenBlock: [: each| (each isMyDictionary | each value isArray | each value isDictionary)];        childrenBlock: [ :item |                 item children.        ] ]! !!MongoDBContentList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 4/2/2017 19:20'!items: aCollection	"aCollection isDictionary		ifTrue: [ 			collectionsList roots: aCollection.			rootItems roots: aCollection keys ]		ifFalse: [ collectionsList roots: aCollection ]"			collectionsList roots: aCollection! !!MongoDBContentList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/2/2017 17:15'!initializeWidgets      rootItems := TreeModel new.	collectionsList := TreeModel  new.	label := self newLabel.		"label text: 'Collections'."		self focusOrder add: collectionsList! !!MongoDBContentList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/20/2017 22:48'!formJson	| jsonList |	jsonList := OrderedCollection  new.	collectionsList		ifNil: [ ^ nil ]		ifNotNil: [ 			"collectionsList hasChildrenBlock: [ :item | item isDictionary ]."			collectionsList roots do: [:item | Transcript show:'{';cr. item associations do: [ :assoc | Transcript show:(Json render: assoc) asText. Transcript show:',';cr. ]. Transcript show:'}';cr. ] ].					"^ jsonList"! !!MongoDBContentList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/8/2016 20:24'!displayBlock: aBlock	collectionsList displayBlock: aBlock! !!MongoDBContentList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/11/2016 19:49'!label	^ label! !!MongoDBContentList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/19/2017 16:37'!getDictionaryId: dictionary	dictionary		associationsDo: [ :assoc | 			assoc key asString = '_id'				ifTrue: [ ^ assoc value asString ] ]! !!MongoDBContentList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/11/2016 19:48'!title	^ 'Documents'! !!MongoDBContentList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 2/6/2016 19:51'!label: aText	label text: aText! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MongoDBContentList class	instanceVariableNames: 'isTree'!!MongoDBContentList class methodsFor: 'spec' stamp: 'KhrystynaMykhailiuk 5/2/2017 17:14'!defaultSpec	<spec: #default>		^ SpecLayout composed		newColumn: [ :column |			column 				add: #label				height: self toolbarHeight;				add: #collectionsList];		yourself			! !!MongoDBContentList class methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/8/2016 21:28'!isTree	^ isTree! !!MongoDBContentList class methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/8/2016 21:28'!isTree: anObject	isTree := anObject! !MongoDBContentList subclass: #MongoCollectionList	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-View'!!MongoCollectionList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 4/2/2017 17:59'!initializeWidgets      rootItems := TreeModel new.	collectionsList := TreeModel  new.	collectionsList iconBlock: [ Smalltalk ui icons mongoCollectionIcon.  ].	label := self newLabel.	label label: 'Collections'.		self focusOrder add: collectionsList! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MongoCollectionList class	instanceVariableNames: ''!!MongoCollectionList class methodsFor: 'spec' stamp: 'KhrystynaMykhailiuk 5/28/2017 22:23'!defaultSpec	<spec: #default>		^ SpecLayout composed		newColumn: [ :column |			column 				add: #label				height: self toolbarHeight;				add: #collectionsList];		yourself! !!MongoCollectionList class methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/8/2016 21:28'!isTree	^ isTree! !!MongoCollectionList class methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/8/2016 21:28'!isTree: anObject	isTree := anObject! !MongoDBContentList subclass: #MongoDatabasesList	instanceVariableNames: 'model list'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-View'!!MongoDatabasesList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/11/2016 19:43'!title	^ 'Databases'! !!MongoDatabasesList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/16/2017 22:08'!whenSelectedItemChanged: aBlock	list whenSelectedItemChanged: aBlock! !!MongoDatabasesList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 2/6/2016 19:54'!list	^ list! !!MongoDatabasesList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/14/2017 20:29'!setBaseList		list deselectAll .	list roots: model getDatabases .		list rootNodeHolder: [ :item |         TreeNodeModel new            content: item;            icon: Smalltalk ui icons mongoDatabaseIcon    ].	list hasChildrenBlock:   [ :parent | parent  isMongoDatabase ].	list childrenBlock: [ :parent | parent collections.].	! !!MongoDatabasesList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/14/2017 13:08'!initializeWidgets      model := MongoDatabasesModel new.	list := TreeModel new.	label := self newLabel.	label label: 'Databases'.	self setBaseList.	"db := Mongo default open databaseNamed: 'Mapless-Tests'."      "self setBaseList."	self focusOrder add: list! !!MongoDatabasesList methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 4/1/2017 21:02'!openWithSpec^ super openWithSpec ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MongoDatabasesList class	instanceVariableNames: ''!!MongoDatabasesList class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/28/2017 22:24'!defaultSpec	<spec: #default>		^ SpecLayout composed		newColumn: [ :column |			column 				add: #label				height: 15;				add: #list];		yourself! !MongoDBContentList subclass: #MongoDocumentsList	instanceVariableNames: 'buttonTreeModel buttonTableModel buttonJsonModel documentsContent'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-View'!!MongoDocumentsList methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/2/2017 17:32'!documentsContent	^ documentsContent! !!MongoDocumentsList methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/19/2017 18:39'!printOnWindow: json	Transcript open.	json asString		do: [ :char | 			Transcript show: char printString.			char = ','				ifTrue: [ Transcript cr ] ]! !!MongoDocumentsList methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/14/2017 23:04'!buttonJsonModel: anObject	buttonJsonModel := anObject! !!MongoDocumentsList methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/14/2017 23:04'!buttonTableModel: anObject	buttonTableModel := anObject! !!MongoDocumentsList methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/14/2017 23:04'!buttonJsonModel	^ buttonJsonModel! !!MongoDocumentsList methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/2/2017 17:32'!documentsContent: anObject	documentsContent := anObject! !!MongoDocumentsList methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/14/2017 23:04'!buttonTableModel	^ buttonTableModel! !!MongoDocumentsList methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/14/2017 23:04'!buttonTreeModel: anObject	buttonTreeModel := anObject! !!MongoDocumentsList methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/14/2017 23:04'!buttonTreeModel	^ buttonTreeModel! !!MongoDocumentsList methodsFor: 'initialize' stamp: 'KhrystynaMykhailiuk 4/23/2017 14:03'!initializePresenter	| document grid |	Transcript clear.	buttonTableModel		action: [ 			document := self owner selectedDocument.			document				ifNotNil: [ 					grid := GridMorph withColumns: document keys.					grid addNewRow: document values.					grid title: (self getDictionaryId: document).					grid openInWorld ]				ifNil: [ self inform: 'Please select document' ] ].	buttonJsonModel		action: [ 			document := self owner selectedDocument.			"document				ifNotNil: [ "					Transcript open.					self formJson.											"json := Json render: document associations.					(TextModel new)						text: json asText;						title: (self getDictionaryId: document);						openWithSpec ]				ifNil: [ self inform: 'Please select document' ] "]! !!MongoDocumentsList methodsFor: 'initialize' stamp: 'KhrystynaMykhailiuk 5/14/2017 11:27'!initializeWidgets|db collection1 documents2 ds |	rootItems := TreeModel new.	collectionsList := TreeModel new.					db := Mongo default open databaseNamed: 'RestaurantsDBS'.collection1 := nil. "db collectionAt: 'restaurants'."documents2 :=nil. ":= (collection1 select: MyDictionary new) collect:[:each | each asMyDictionary ]."	"ds := FTTreeDataSource		roots: (documents2)		children: [ :data | (data isDictionary | data value isArray | data value isDictionary ) ifTrue: [ data children ] ifFalse:[ Dictionary new.] ]."	documentsContent := nil."(FTTableMorph new extent: 540 @ 330; dataSource: ds) asSpecAdapter.	"		"collectionsList := GridMorph  new."		collectionsList rootNodeHolder: [ :item |         TreeNodeModel new            content: item;            icon: Smalltalk ui icons mongoDocumentIcon.    ].	label := self newLabel.	buttonTreeModel := ButtonModel new.	buttonTableModel := ButtonModel new.	buttonJsonModel := ButtonModel new.	buttonTreeModel label: 'As Tree'.	buttonTableModel label: 'As Table'.	buttonJsonModel label: 'As Json'.	label label: 'Documents'.	self focusOrder add: collectionsList! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MongoDocumentsList class	instanceVariableNames: ''!!MongoDocumentsList class methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/8/2016 21:28'!isTree	^ isTree! !!MongoDocumentsList class methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/8/2016 21:28'!isTree: anObject	isTree := anObject! !!MongoDocumentsList class methodsFor: 'spec' stamp: 'KhrystynaMykhailiuk 5/14/2017 11:28'!defaultSpec	<spec: #default>		^ SpecLayout composed		newColumn: [ :column |			column 								newRow: [:rowTitle| 					rowTitle 							add: #label;				 							newRow:[:buttonRow|								buttonRow 								"add:#buttonTreeModel;"								add:#buttonTableModel;								add:#buttonJsonModel 																] 											] height: self toolbarHeight;				add: #collectionsList				];		yourself ! !ComposableModel subclass: #SpecFTTableMorph	instanceVariableNames: 'morph'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-View'!!SpecFTTableMorph methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/9/2017 23:26'!initializeWidetsmorph := (FTTableMorph new) asSpecAdapter .! !DynamicComposableModel subclass: #TabsDynamicArea	instanceVariableNames: 'tabManager tab versionsDictionary'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-View'!!TabsDynamicArea methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/15/2017 23:44'!helpText^ 'tab'! !!TabsDynamicArea methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/31/2017 01:03'!initializePresenter	tabManager		whenTabSelected: [ :selectedTab | 			selectedTab relatedCollection isNil				ifFalse: [ selectedTab owner owner owner owner statusBar						text:							'VERSION  ' , selectedTab version asString , ' ' , selectedTab label , '   count of elements: '								, selectedTab relatedCollection size asString ]				ifTrue: [ selectedTab owner owner owner owner statusBar						text: selectedTab label ].			selectedTab modelHolder isTreeModel				ifTrue: [ selectedTab modelHolder						whenSelectedItemChanged: [ :item | 							selectedTab owner owner owner								selectedDocument: item;								selectedTabVersion: selectedTab version.							selectedTab owner owner owner selectedCollectionName: selectedTab label ] ] ]! !!TabsDynamicArea methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/28/2017 23:36'!initializeWidgets							tabManager := TabManagerModel new.		tabManager color: Color white.		versionsDictionary := Dictionary new.			self assign: tabManager to: #tabs.! !!TabsDynamicArea methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/14/2017 12:35'!tabManager: anObject	tabManager := anObject! !!TabsDynamicArea methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/28/2017 23:35'!versionsDictionary	^ versionsDictionary! !!TabsDynamicArea methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/14/2017 20:33'!addTab: model	tab := TabModel new		label: 'NewTab';		model: model.	tabManager		addTab: tab;		yourself! !!TabsDynamicArea methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/28/2017 23:35'!versionsDictionary: anObject	versionsDictionary := anObject! !!TabsDynamicArea methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/21/2017 16:14'!addTab: model name: aName	tab := TabModel new	icon: Smalltalk ui icons mongoIcon;		label: aName;		model: model;		modelHolder: model;		selected: true.	tabManager		addTab: tab;		yourself.			! !!TabsDynamicArea methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/29/2017 20:45'!updateVersionDictionary: aName	| count |	versionsDictionary		at: aName		ifPresent: [ count := versionsDictionary at: aName.			versionsDictionary at: aName put: count + 1.			^ count + 1].	versionsDictionary at: aName ifAbsent: [ versionsDictionary at: aName put: 1.		^ 1]! !!TabsDynamicArea methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/29/2017 21:28'!addTab: model name: aName fromCollection: aCollection|versionNumber|versionNumber  := self updateVersionDictionary: aName.	tab := TabModel new	icon: Smalltalk ui icons mongoIcon;		label: aName;		model: model;		modelHolder: model;		relatedCollection: aCollection;		version: versionNumber;		selected: true.	tabManager		addTab: tab;		yourself.				^versionNumber.			! !!TabsDynamicArea methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/14/2017 18:55'!addTab	"tabManager addTab: (TabModel new		label: 'fooTab';		model: 			(DynamicComposableModel new 				layout: SpecLayout composed;				yourself))"! !!TabsDynamicArea methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/14/2017 19:36'!removeAllTabs! !!TabsDynamicArea methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/14/2017 12:35'!tabManager	^ tabManager! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TabsDynamicArea class	instanceVariableNames: ''!!TabsDynamicArea class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/14/2017 12:48'!defaultSpec	<spec: #default>	^ SpecLayout composed		add: #tabs;		yourself! !ComposableModel subclass: #MongoDBContentListFastTree	instanceVariableNames: 'label collectionsList rootItems'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-HelpfulExamples'!!MongoDBContentListFastTree methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/2/2017 17:30'!initializeWidgets	collectionsList := FTTableMorph new.	label := 'Label'.		"label text: 'Collections'."		self focusOrder add: collectionsList! !!MongoDBContentListFastTree methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/2/2017 17:33'!rootItems	^ rootItems! !!MongoDBContentListFastTree methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/2/2017 17:33'!collectionsList	^ collectionsList! !!MongoDBContentListFastTree methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/2/2017 17:33'!label	^ label! !!MongoDBContentListFastTree methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/2/2017 17:33'!label: anObject	label := anObject! !!MongoDBContentListFastTree methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/2/2017 17:33'!rootItems: anObject	rootItems := anObject! !!MongoDBContentListFastTree methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 5/2/2017 17:33'!collectionsList: anObject	collectionsList := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MongoDBContentListFastTree class	instanceVariableNames: ''!!MongoDBContentListFastTree class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/2/2017 17:30'!defaultSpec	<spec: #default>		^ SpecLayout composed		newColumn: [ :column |			column 				add: #label				height: self toolbarHeight;				add: #collectionsList];		yourself			! !TestCase subclass: #ExampleSetTest1	instanceVariableNames: 'full empty'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-Tests'!!ExampleSetTest1 methodsFor: 'running' stamp: 'Vika 4/25/2017 12:35'!setUp	empty := Set new.	full := Set with: 5 with: #abc! !!ExampleSetTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 12:35'!testIncludes	self assert: (full includes: 5).	self assert: (full includes: #abc)! !!ExampleSetTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 12:35'!testAdd	empty add: 5.	self assert: (empty includes: 5)! !!ExampleSetTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 12:35'!testGrow	empty addAll: (1 to: 100).	self assert: empty size = 100! !!ExampleSetTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 12:35'!testRemove	full remove: 5.	self assert: (full includes: #abc).	self deny: (full includes: 5)! !!ExampleSetTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 12:35'!testIllegal	self 		should: [empty at: 5] 		raise: self defaultTestError.	self 		should: [empty at: 5 put: #abc] 		raise: self defaultTestError! !!ExampleSetTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 12:35'!testOccurrences	self assert: (empty occurrencesOf: 0) = 0.	self assert: (full occurrencesOf: 5) = 1.	full add: 5.	self assert: (full occurrencesOf: 5) = 1! !TestCase subclass: #SUnitTest1	instanceVariableNames: 'hasRun hasSetup hasRanOnce'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-Tests'!!SUnitTest1 methodsFor: 'helpers' stamp: 'Vika 4/25/2017 17:44'!deprecatedMessage	self deprecated: 'Deprecated method used by #testIgnoreDeprecationWarnings' on: '' in: ''! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testDialectLocalizedException	self		should: [self classForTestResult signalFailureWith: 'Foo']		raise: self defaultTestFailure.	self		should: [self classForTestResult signalErrorWith: 'Foo']		raise: self defaultTestError.! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testSuite	| suite result |	suite := self classForTestSuite new.	suite		addTest: (self class selector: #noop);		addTest: (self class selector: #fail);		addTest: (self class selector: #error).	result := suite run.	self		assertForTestResult: result		runCount: 3		passed: 1		failed: 1		errors: 1! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testRaiseDeprecationWarnings	| case result |	case := self class selector: #raiseDeprecationWarnings.	result := case run.	self assert: result defects asArray equals: (Array with: case).	self		assertForTestResult: result		runCount: 1		passed: 0		failed: 1		errors: 0! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testFail	| case result |	case := self class selector: #fail.	result := case run.	self		assertForTestResult: result		runCount: 1		passed: 0		failed: 1		errors: 0! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testExpectedFailure	| case result |	case := self class selector: #expectedFailureFails.	self deny: case shouldPass.	result := case run.	self		assertForTestResult: result		runCount: 1		passed: 0		failed: 0		errors: 0		expectedFailures: 1.! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testError	| case result |	case := self class selector: #error.	result := case run.	self		assertForTestResult: result		runCount: 1		passed: 0		failed: 0		errors: 1.	case := self class selector: #errorShouldntRaise.	result := case run.	self 		assertForTestResult: result		runCount: 1		passed: 0		failed: 0		errors: 1! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testIsNotRerunOnDebug	| case |	case := self class selector: #testRanOnlyOnce.	case run.	case debug! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testRunning	(Delay forSeconds: 2) wait			! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testIgnoreDeprecationWarnings	| oldRaiseWarning |	oldRaiseWarning := Deprecation raiseWarning.	[ Deprecation raiseWarning: false.	self deprecatedMessage.	self assert: true ]		ensure: [ Deprecation raiseWarning: oldRaiseWarning ]! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testException	self		should: [self error: 'foo']		raise: self defaultTestError! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testExpectedFailurePass	| case result |	case := self class selector: #expectedFailurePasses.	self deny: case shouldPass.	result := case run.	self		assertForTestResult: result		runCount: 1		passed: 0		failed: 1		errors: 0		expectedFailures: 0.! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!errorShouldntRaise	self someMessageThatIsntUnderstood! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testFileOutResult	| suite result fileout |	suite := self classForTestSuite new.	suite		addTest: (self class selector: #noop);		addTest: (self class selector: #fail);		addTest: (self class selector: #error).	result := suite run.	fileout := String streamContents: [ :aStream | result fileOutOn: aStream ].	self		assert: fileout		equals:			'3 run, 1 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, 0 unexpected passesFailures:SUnitTest(TestAsserter)>>#failErrors:SUnitTest>>#error'! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testAssert	self assert: true.	self deny: false! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!raiseDeprecationWarnings	| oldRaiseWarning |	oldRaiseWarning := Deprecation raiseWarning.	[ Deprecation raiseWarning: true.	self deprecatedMessage.	self fail ]		ensure: [ Deprecation raiseWarning: oldRaiseWarning ]! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testRan	| case |	case := self class selector: #setRun.	case resources do: [:each | each availableFor: case].	[case setUp.	case performTest] ensure: [		self assert: case hasSetup.		self assert: case hasRun.		case tearDown.		case cleanUpInstanceVariables].	self assert: case hasSetup isNil.	self assert: case hasRun isNil.! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testDefects	| result suite error failure |	suite := self classForTestSuite new.	suite addTest: (error := self class selector: #error).	suite addTest: (failure := self class selector: #fail).	result := suite run.	self assert: result defects asArray = (Array with: error with: failure).	self		assertForTestResult: result		runCount: 2		passed: 0		failed: 1		errors: 1! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testResult	| case result |	case := self class selector: #noop.	result := case run.	self		assertForTestResult: result		runCount: 1		passed: 1		failed: 0		errors: 0! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testWithExceptionDo	self		should: [self error: 'foo']		raise: self defaultTestError		withExceptionDo: [:exception |			self assert: (exception description includesSubstring: 'foo')		]			! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testSelectorWithArg: anObject	"should not result in error"! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testShould	self		should: [true];		shouldnt: [false]! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!expectedFailures	^super expectedFailures "#() "! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testExpectedFailureDetection	self assert: self expectedFailures size = 2.	self assert: (self expectedFailures includesAllOf: #(expectedFailureFails expectedFailurePasses))! !!SUnitTest1 methodsFor: 'testing' stamp: 'Vika 4/25/2017 17:44'!testRanOnlyOnce	self assert: hasRanOnce ~= true.	hasRanOnce := true! !!SUnitTest1 methodsFor: 'accessing' stamp: 'Vika 4/25/2017 17:44'!hasSetup	^hasSetup! !!SUnitTest1 methodsFor: 'accessing' stamp: 'Vika 4/25/2017 17:44'!hasRun	^hasRun! !!SUnitTest1 methodsFor: 'private' stamp: 'Vika 4/25/2017 17:44'!assertForTestResult: aResult runCount: aRunCount passed: aPassedCount failed: aFailureCount errors: anErrorCount	self		assert: aResult runCount = aRunCount;		assert: aResult passedCount = aPassedCount;		assert: aResult failureCount = aFailureCount;		assert: aResult errorCount = anErrorCount! !!SUnitTest1 methodsFor: 'private' stamp: 'Vika 4/25/2017 17:44'!setRun	hasRun := true! !!SUnitTest1 methodsFor: 'private' stamp: 'Vika 4/25/2017 17:44'!expectedFailureFails	<expectedFailure>	self assert: false.! !!SUnitTest1 methodsFor: 'private' stamp: 'Vika 4/25/2017 17:44'!error	3 zork! !!SUnitTest1 methodsFor: 'private' stamp: 'Vika 4/25/2017 17:44'!assertForTestResult: aResult runCount: aRunCount passed: aPassedCount failed: aFailureCount errors: anErrorCount expectedFailures: anExpectedFailureCount	self		assert: aResult runCount = aRunCount;		assert: aResult expectedPassCount = aPassedCount;		assert: aResult failureCount = aFailureCount;		assert: aResult errorCount = anErrorCount;		assert: aResult expectedDefectCount = anExpectedFailureCount! !!SUnitTest1 methodsFor: 'private' stamp: 'Vika 4/25/2017 17:44'!noop! !!SUnitTest1 methodsFor: 'private' stamp: 'Vika 4/25/2017 17:44'!expectedFailurePasses	<expectedFailure>	self assert: true.! !!SUnitTest1 methodsFor: 'running' stamp: 'Vika 4/25/2017 17:44'!setUp	hasSetup := true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SUnitTest1 class	instanceVariableNames: ''!!SUnitTest1 class methodsFor: 'history' stamp: 'Vika 4/25/2017 17:45'!lastStoredRun	^ ((Dictionary new) add: (#passed->((Set new) add: #testWithExceptionDo; add: #testAssert; add: #testRanOnlyOnce; add: #testDialectLocalizedException; add: #testFail; add: #testDefects; add: #testIsNotRerunOnDebug; add: #testResult; add: #testRunning; add: #testError; add: #testException; add: #testShould; add: #testSuite; yourself)); add: (#timeStamp->'22 November 2008 10:11:35 pm'); add: (#failures->((Set new))); add: (#errors->((Set new))); yourself)! !Object subclass: #KeyboardControllers	instanceVariableNames: 'model'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-Controller'!!KeyboardControllers methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/12/2016 22:52'!onKeyPressed: aKey action: anAction"(aKey = Character arrowLeft)  ifTrue: [ ].(aKey = Character arrowRight) ifTrue: [ ]."(aKey = $d)ifTrue: [ anAction ].(aKey = $c) ifTrue: [ anAction].(aKey = $s) ifTrue:[anAction].(aKey = $r)ifTrue: [anAction].(aKey = $u)ifTrue: [ anAction].! !!KeyboardControllers methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/9/2016 14:12'!attachToView: view	view addArrowController:  self.! !!KeyboardControllers methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/12/2016 18:05'!onKeyPressed: aKey"(aKey = Character arrowLeft)  ifTrue: [ ].(aKey = Character arrowRight) ifTrue: [ ]."(aKey = $d)ifTrue: [ "model delete. "].(aKey = $c) ifTrue: [ ].(aKey = $s) ifTrue:[].(aKey = $r)ifTrue: [].(aKey = $u)ifTrue: [ ].! !!KeyboardControllers methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 14:13'!model: anObject	model := anObject! !!KeyboardControllers methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 14:13'!model	^ model! !Object subclass: #MouseControllers	instanceVariableNames: 'model keyChar'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-Controller'!!MouseControllers methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 12:51'!keyChar	^ keyChar! !!MouseControllers methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 12:51'!model	^ model! !!MouseControllers methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 12:51'!model: anObject	model := anObject! !!MouseControllers methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 12:51'!keyChar: anObject	keyChar := anObject! !!MouseControllers methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 12:51'!attachToView: view	view addMouseController:  self.! !!MouseControllers methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/9/2016 12:46'!location: location modifier: mod"Transcript show: (model gameState tileClickedAt: location newSelection: isNewSelection modifier: mod);cr.""Transcript show: 'yes';cr."self subclassResponsibility.	! !MouseControllers subclass: #LeftMouseControllers	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-Controller'!!LeftMouseControllers methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/9/2016 12:49'!location: location modifier: mod"Transcript show: (model gameState tileClickedAt: location newSelection: isNewSelection modifier: mod);cr.""Transcript show: 'yes';cr.""mod yellowButtonPressed ifTrue:[^model gameState tileClickedToFlag: location.].""mod redButtonPressed ifTrue: [	(self keyChar = 'n')ifTrue:[^model gameState newGame.   ]	                            ifFalse:[^ model gameState tileClickedAt: location.].    	].                   "   ! !MouseControllers subclass: #RightMouseControllers	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-Controller'!!RightMouseControllers methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/9/2016 12:50'!location: location modifier: mod"Transcript show: (model gameState tileClickedAt: location newSelection: isNewSelection modifier: mod);cr."""Transcript show: 'yes';cr."mod yellowButtonPressed ifTrue:[^model gameState tileClickedToFlag: location.].""mod redButtonPressed ifTrue: [^  model gameState tileClickedAt: location.].     "                       ! !Object subclass: #FunctionalWindowModel	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-Model'!FunctionalWindowModel subclass: #MongoBrowserCreateWindowModel	instanceVariableNames: 'databaseName collectionName documentScript'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-Model'!!MongoBrowserCreateWindowModel methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/19/2017 11:29'!collectionName: anObject	collectionName := anObject! !!MongoBrowserCreateWindowModel methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/19/2017 11:29'!databaseName: anObject	databaseName := anObject! !!MongoBrowserCreateWindowModel methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/19/2017 11:29'!documentScript: anObject	documentScript := anObject! !!MongoBrowserCreateWindowModel methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/19/2017 11:29'!collectionName	^ collectionName! !!MongoBrowserCreateWindowModel methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/19/2017 11:29'!documentScript	^ documentScript! !!MongoBrowserCreateWindowModel methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/19/2017 11:29'!databaseName	^ databaseName! !FunctionalWindowModel subclass: #MongoBrowserDeleteWindowModel	instanceVariableNames: 'withField withValue'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-Model'!!MongoBrowserDeleteWindowModel methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 19:44'!withField	^ withField! !!MongoBrowserDeleteWindowModel methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 19:44'!withField: anObject	withField := anObject! !!MongoBrowserDeleteWindowModel methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 19:44'!withValue	^ withValue! !!MongoBrowserDeleteWindowModel methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 2/26/2017 19:44'!withValue: anObject	withValue := anObject! !Object subclass: #MongoBrowserHelper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-Model'!!MongoBrowserHelper methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/20/2017 22:20'!printCollection:collectioncollection do:[:item | Transcript show: item.]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MongoBrowserHelper class	instanceVariableNames: ''!!MongoBrowserHelper class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/1/2017 16:00'!whetherOptionsInQuery: query	((query indexOfSubCollection: 'multi') == 0)		ifTrue: [  ^0. ]		ifFalse: [ ^10.  ]! !!MongoBrowserHelper class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 4/22/2017 23:06'!getSelectExpression: query	query		ifNil: [ ^ query ]		ifNotNil: [ Transcript				clear;				show: (query copyFrom: (query indexOf: $() + 1 to: (query indexOf: $)) - 1).			^ query copyFrom: (query indexOf: $() + 1 to: (query indexOf: $)) - 1 ]! !!MongoBrowserHelper class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/14/2017 15:02'!treeBranches: itemsitems ifNil: [ ^ nil ]		ifNotNil: [ 			items hasChildrenBlock: [: each| (each isMyDictionary | each value isArray | each value isDictionary)];        childrenBlock: [ :item |                 item children.        ] ].^items.! !!MongoBrowserHelper class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/20/2017 22:26'!printCollection:collectionTranscript open.collection do:[:item | Transcript show: item.]! !!MongoBrowserHelper class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/21/2017 19:54'!formJson: collectionList	| jsonList jsonString |	jsonList := OrderedCollection  new.	collectionList		ifNil: [ ^ nil ]		ifNotNil: [ 			"collectionsList hasChildrenBlock: [ :item | item isDictionary ]."			collectionList roots do: [:item | Transcript show:'{';cr. item associations do: [ :assoc | Transcript show:(Json render: assoc) asText. Transcript show:',';cr.					]. Transcript show:'}';cr. ] ].		! !!MongoBrowserHelper class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 4/25/2017 22:50'!getExpression: query	query		ifNil: [ ^ query ]		ifNotNil: [ Transcript				clear;				show: (query copyFrom: (query indexOf: $() + 1 to: (query lastIndexOf: $)) - 1).			^ query copyFrom: (query indexOf: $() + 1 to: (query lastIndexOf: $)) - 1 ]! !!MongoBrowserHelper class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/29/2017 23:26'!convertExpressionForUpdate: query|encloseExpr updateCondition updateData index|	query		ifNil: [ ^ query ]		ifNotNil: [ "Transcript				clear;				show: (query copyFrom: (query indexOf: $() + 1 to: (query lastIndexOf: $)) - 1)."					encloseExpr := query copyFrom: (query indexOf: $() + 1 to: (query lastIndexOf: $)) - 1.				index :=  encloseExpr indexOf: $}.								updateCondition := encloseExpr copyFrom: 1 to: (encloseExpr indexOf: $}).				updateData := encloseExpr copyFrom: index + 2  to: (encloseExpr lastIndexOf: $}).				^ Association  key:(STON fromString: updateCondition) 								 value: (STON fromString: updateData).			]! !Object subclass: #MongoBrowserModel	instanceVariableNames: 'viewer mainViewer'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-Model'!!MongoBrowserModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/5/2018 22:36'!openmainViewer  openWithSpec.! !!MongoBrowserModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/5/2018 22:35'!mainViewer	^ mainViewer! !!MongoBrowserModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/5/2018 22:18'!addView:aView     "aView browserModel: self."mainViewer := aView.! !!MongoBrowserModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/5/2018 22:34'!viewer: anObject	viewer := anObject! !!MongoBrowserModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/4/2018 20:17'!initializesuper initialize ! !!MongoBrowserModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/5/2018 22:31'!viewer	^ viewer! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MongoBrowserModel class	instanceVariableNames: ''!!MongoBrowserModel class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/4/2018 23:47'!formQuery: query	| expression |	expression := MongoBrowserHelper getSelectExpression: query.	expression ifNil: [ ^ expression ] ifNotNil: [ ^ STON fromString: expression ].! !MongoBrowserModel subclass: #MongoBrowserCoreModel	instanceVariableNames: 'mongoState'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-Model'!!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/29/2017 23:20'!deleteDocuments: localViewer data: deleteModel	| repo "field2 value2 classDefinition1 classDefinition2" |	localViewer selectedCollection = nil		ifFalse: [ 			repo := MaplessMongoRepository onDatabaseName: localViewer selectedDatabase name.			"field1 := UIManager default request: 'Delete documents with field:'.			(field1 isNil or: [ field1 isEmpty ])				ifTrue: [ ^ nil ].			value1 := UIManager default request: 'Delete documents where ' , field1 , ' is'.			(value1 isNil or: [ value1 isEmpty ])				ifTrue: [ ^ nil ]."			localViewer selectedCollection delete: {(deleteModel withField -> deleteModel withValue)} asDictionary ]		ifTrue: [ 			UIManager inform: 'Please select a collection'.			^ false ].	"field1 = nil | (value1 = nil)		ifTrue: [ ^ false ]."	^ true! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/18/2017 15:33'!questionDropDBS: localViewer^ UIManager default question: 'Are you sure you want to drop a ' asText , localViewer  selectedDatabase name asText allBold, ' database ?' asText title: 'Drop database'.! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/21/2017 20:59'!createIndex: aName viewer: localViewer|uniqueName|uniqueName  := ('unique_', aName) asString.localViewer selectedDatabase command: {        'createIndexes' -> localViewer selectedCollection name.        'indexes' -> {            {                'key' -> {                    aName-> 1.                } asDictionary.                'name' -> uniqueName.            } asDictionary.        }    } asDictionary.! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:10'!formatDocument:dict| return |dict ifNil: [ ^nil. ]ifNotNil: [     return := dict associations collect: [ :assoc |  assoc key asString, '  ->  ', assoc value asString ]].! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/14/2017 19:17'!refresh: localViewer"self setEmptyContent: localViewer."localViewer databases setBaseList.! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/18/2017 15:35'!questionDropDocument: localViewer^ UIManager default question: 'Are you sure you want to drop a ' asText, localViewer  selectedDocument name asText allBold, ' document ?' asText title: 'Drop document'.! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/19/2017 13:39'!deleteself viewer menuDelete.! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/29/2017 22:08'!insertDocuments: localViewer	| query db collection result |	localViewer selectedCollection		ifNil: [ UIManager inform: 'Please select a collection'.			^ nil ]		ifNotNil: [ query := self getQueryForInsert: localViewer.			query				ifNil: [ ^ nil ]				ifNotNil: [ 					db := Mongo default open databaseNamed: localViewer selectedCollection database name.					collection := db collectionAt: (localViewer selectedCollection name).					"Transcript show: query."					result := collection add: query.					^  result] ]! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 4/22/2017 21:13'!createDocument: localViewer|repo  classDefinition|(localViewer selectedCollection  = nil )ifFalse:[repo := MaplessMongoRepository onDatabaseName: localViewer selectedDatabase name.		classDefinition := UIManager default 		multiLineRequest: 'Write smaltalk script to create document:'		initialAnswer: localViewer  selectedCollection name, ' new '		answerHeight: 100.	(classDefinition isNil or: [ classDefinition isEmpty ])		ifTrue: [ ^ nil.].	repo do:[ self class compiler evaluate: classDefinition].	] ifTrue:[UIManager inform: 'Please select a collection'. ^false.].(classDefinition = nil)ifTrue: [ ^false.].^true.! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/29/2017 23:20'!dropDocument: localViewer|res dict|res:=self questionDropDocument:localViewer. (res == true) & (res~=nil) ifTrue:[	dict := ( Dictionary  new).	dict at:'_id' put: (localViewer  selectedDocument at:'_id') .	localViewer selectedCollection delete: dict."collection: localViewer selectedCollection name." "self viewer selectedDatabase: nil."^true].^false."delete: aDictionary collection: aString 	root delete: aDictionary collection: name , '.' , aString"! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/29/2017 23:20'!selectDocuments: localViewer	| query db collection result |	localViewer selectedCollection		ifNil: [ UIManager inform: 'Please select a collection'.			^ nil ]		ifNotNil: [ query := self getQueryForSelect: localViewer.			query				ifNil: [ ^ nil ]				ifNotNil: [ 					db := Mongo default open databaseNamed: localViewer selectedCollection database name.					collection := db collectionAt: localViewer selectedCollection name.					query := query asMyDictionary.								result := collection select: query.						^ result. ] ]! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/29/2017 21:59'!updateDocuments: localViewer	| query db collection result isOptions assocForUpdate |	localViewer selectedCollection		ifNil: [ UIManager inform: 'Please select a collection'.			^ nil ]		ifNotNil: [ query := self getQueryForUpdate: localViewer.			query isNil				ifFalse: [ assocForUpdate := MongoBrowserHelper convertExpressionForUpdate: query.					isOptions := MongoBrowserHelper whetherOptionsInQuery: query.					assocForUpdate						ifNil: [ ^ nil  ]						ifNotNil: [ db := Mongo default open databaseNamed: localViewer selectedCollection database name.							collection := db collectionAt: localViewer selectedCollection name.							result := collection update: assocForUpdate key with: assocForUpdate value flags: isOptions.							^ result ] ]				ifTrue: [ ^ nil ] ]! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/19/2017 19:03'!editDocument: localViewer|repo  field1 value1 field2 value2 "classDefinition1 classDefinition2"|(localViewer selectedCollection  = nil )ifFalse:[repo := MaplessMongoRepository onDatabaseName: localViewer  selectedDatabase name.		field1 := UIManager default request: 'Update documents in ' asText, localViewer  selectedCollection name asText allBold,' collection with field:' asText.				(field1 isNil or: [ field1 isEmpty ])		ifTrue: [ ^ nil.].			value1:= UIManager default request: 'Update documents where ' asText,field1 asText allBold,' is' asText.		(value1 isNil or: [ value1 isEmpty ])		ifTrue: [ ^ nil.].				field2 := UIManager default request: 'Update documents in ' asText, localViewer  selectedCollection name asText allBold,' collection following field:' asText.			(field2 = '_id') ifTrue:[UIManager default inform:'_id is immutable'. ^nil.].		(field2 isNil or: [ field2 isEmpty ])		ifTrue: [ ^ nil.].			value2:= UIManager default request: 'Set documents where ' asText ,field2 asText allBold,' is ' asText.		(value1 isNil or: [ value1 isEmpty ])		ifTrue: [ ^ nil.].			"classDefinition1 := UIManager default 		multiLineRequest: 'Update collections where:'		initialAnswer: ''		answerHeight: 10."		"(field1 isNil or: [ field1 isEmpty ])		ifTrue: [ ^ nil.].				classDefinition2 := UIManager default 		multiLineRequest: 'Update to:'		initialAnswer: ''		answerHeight: 10.		(classDefinition2 isNil or: [ classDefinition2 isEmpty ])		ifTrue: [ ^ nil.].	"				"collectionFirst update: {'hj'-> 'hjk'} asDictionary with: {'hj'->'hjkk'} asDictionary. "	repo do:[ localViewer selectedCollection update:{field1 -> value1} asDictionary with: {field2 -> value2} asDictionary].	] ifTrue:[UIManager inform: 'Please select collection'. ^false.].((field1 = nil) | (value1 = nil) |(field2 = nil) | (value2 = nil))ifTrue: [ ^false.].^true.! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/4/2018 19:01'!createDBS: viewerModel	| dbsName collName script |	dbsName := Mongo default open databaseNamed: viewerModel databaseName.	collName := dbsName collectionAt: viewerModel collectionName.	collName = ' '		ifTrue: [ UIManager inform: 'Collection name already exist'.			^ false ]		ifFalse: [ dbsName addCollection: viewerModel collectionName ].	script := viewerModel documentScript.	script ~= ' '		ifTrue: [ script := MongoBrowserCoreModel formQuery: script.			collName insert: (Array with: script) ].	^ true! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/12/2016 18:35'!dropDBS: localViewer|res|res:=self questionDropDBS:localViewer  . (res == true) & (res~=nil) ifTrue:[localViewer selectedDatabase drop. "self viewer selectedDatabase: nil."^true].^false.! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/28/2017 22:13'!getQueryForUpdate: localViewer	|query|	query := UIManager default multiLineRequest: 	'Write query to update documents in ' asText				, localViewer selectedCollection name asText allBold , ' collection'					initialAnswer: 'db.', localViewer selectedCollection name,'.update (				            {" " : " "},				            {  					            "$set": { " ": " " } 				            },				            {"multi": true}					            )'	answerHeight: 200.		query ifNil: [ ^ nil. ]		ifNotNil: [ "Transcript show: (expressionsForUpdate key); cr; show: (expressionsForUpdate value)."	^ query.]! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/31/2017 01:33'!help^'  Using this program you can:  > Create databases, collections or documents.   > Delete concrete databases, collections or documents.  > Refresh databases.  > Update documents.  > Insert documents.  > Create inexes  > Show indexes  Button Load data selects all data from collection.  Button Refresh databases list and their content.  Button Query - you can write selects to collections in databases.  Button Delete - select and delete some documents.  Button Update - update fields in documents.  Shortcuts:     d - choose delete database, collection or document.    c - choose create database, collection or document.    u - update documents.    s - selects to documents in databases.    r - refresh all content.    i - inserts document    j - form documents into JSON'! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/21/2017 18:19'!deleteDocuments: localViewer| query db collection result |	localViewer selectedCollection		ifNil: [ UIManager inform: 'Please select a collection'.			^ nil. ]		ifNotNil: [ query := self getQueryForDelete: localViewer.			query				ifNil: [ ^ nil. ]				ifNotNil: [ db := Mongo default open databaseNamed: localViewer selectedCollection database name.					collection := db collectionAt: localViewer selectedCollection name.					result := collection delete: query asMyDictionary.									^ result ] ]	"| repo field1 value1 |	localViewer selectedCollection = nil		ifFalse: [ 			repo := MaplessMongoRepository onDatabaseName: localViewer selectedDatabase name.			field1 := UIManager default request: 'Delete documents with field:'.			(field1 isNil or: [ field1 isEmpty ])				ifTrue: [ ^ nil ].			value1 := UIManager default request: 'Delete documents where ' , field1 , ' is'.			(value1 isNil or: [ value1 isEmpty ])				ifTrue: [ ^ nil ].			localViewer selectedCollection delete: {(field1 -> value1)} asDictionary ]		ifTrue: [ 			UIManager inform: 'Please select a collection'.			^ false ].	field1 = nil | (value1 = nil)		ifTrue: [ ^ false ].	^ true"! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/30/2017 23:17'!getQueryForInsert: localViewer	| query expression |	query := UIManager default multiLineRequest: 			'Write document to insert into ' asText				, localViewer selectedCollection name asText allBold , ' collection'				initialAnswer: 'db.', localViewer selectedCollection name,'.insert (				            {				            " " : " ",				            " " : [ , ]				            }				            )'	answerHeight: 200.	expression := MongoBrowserHelper getExpression: query.	expression ifNil: [ ^ expression ] ifNotNil: [ ^ STON fromString: expression ].	! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/29/2017 22:24'!getQueryForSelect: localViewer	| query expression|	query := UIManager default multiLineRequest: 	'Write query to select documents from ' asText				, localViewer selectedCollection name asText allBold , ' collection'					initialAnswer: 'db.', localViewer selectedCollection name,'.find (				            {				            " " : " "				            }				            )'	answerHeight: 200.		expression := MongoBrowserHelper getExpression: query.		expression ifNil: [ ^ expression. ]		ifNotNil: [ 	^ STON fromString: expression.]! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/21/2017 16:43'!dropCollection: localViewer|res|res:=self questionDropCollection:localViewer . (res == true) & (res~=nil) ifTrue:[localViewer selectedCollection drop. "self viewer selectedDatabase: nil."^true].^false.! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/12/2016 13:43'!setEmptyContent: localViewer(localViewer selectedDatabase) ifNotNil: [ localViewer collections items: (localViewer browserState collectionsIn: localViewer selectedDatabase) .(localViewer selectedCollection)  ifNotNil: [ localViewer content items: (localViewer selectedCollection select: MyDictionary new);							treeBranches.].							]! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/28/2017 21:20'!getIndexes: localViewer^ ((localViewer selectedDatabase) command: {        'listIndexes' -> localViewer selectedCollection name           } asDictionary)! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 2/19/2017 11:14'!questionDropCollection: localViewer^ UIManager default question: 'Are you sure you want to drop a ' asText, localViewer  selectedCollection name asText  allBold, ' collection ?' asText title: 'Drop Collection'.! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/28/2017 22:12'!getQueryForDelete: localViewer	| query expression|	query := UIManager default multiLineRequest: 	'Write query to delete documents from ' asText				, localViewer selectedCollection name asText allBold , ' collection'					initialAnswer: 'db.', localViewer selectedCollection name,'.remove (				            {" " : " "}										            )'	answerHeight: 200.		expression := MongoBrowserHelper getExpression: query.		expression ifNil: [ ^ expression. ]		ifNotNil: [ 	^ STON fromString: expression.]! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 4/22/2017 15:24'!createDBS	| repo dbName collName classDefinition |	dbName := UIManager default request: 'Input database name'.	dbName = nil		ifFalse: [ 			repo := MaplessMongoRepository onDatabaseName: dbName.			collName := UIManager default request: 'Collection name'.			collName = nil				ifFalse: [ 					"Transcript show:' ';show: (self checkClassExist: collName); show: ' ';cr."					(self checkClassExist: collName)						ifFalse: [ 							Mapless								subclass: collName								instanceVariableNames: ''								classVariableNames: ''								poolDictionaries: ''								category: 'Mapless-Models' ].					classDefinition := UIManager default						multiLineRequest: 'Write smaltalk script to create document:'						initialAnswer: collName , ' new '						answerHeight: 100.					(classDefinition isNil or: [ classDefinition isEmpty ])						ifTrue: [ ^ nil ].					repo do: [ self class compiler evaluate: classDefinition ] ] ].	dbName = nil		ifTrue: [ ^ false ].	^ true! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:21'!initialize	super initialize! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/1/2017 15:47'!checkClassExist: className	| strClassName |	strClassName := className asString.	((RPackageOrganizer default packageNamed: 'Mapless') definedClasses		collect: [ :each | each asString ])		do: [ :n | 			n = strClassName				ifTrue: [ ^ true ] ].	^ false! !!MongoBrowserCoreModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/28/2017 21:09'!createCollection: localViewer|collName|localViewer selectedDatabase isNil ifFalse:["repo := MaplessMongoRepository onDatabaseName: localViewer  selectedDatabase name."collName := UIManager default request: 'Collection name'.collName isNil ifFalse:[	localViewer selectedDatabase addCollection: collName.	UIManager inform: 'Collection created'."(self checkClassExist: collName)ifFalse:[ 	Mapless subclass: collName		instanceVariableNames: '' 		classVariableNames: ''		poolDictionaries: ''		category: 'Mapless-Models'	].classDefinition := UIManager default 		multiLineRequest: 'Write smaltalk script to create document:'		initialAnswer:collName, ' new '		answerHeight: 100.	(classDefinition isNil or: [ classDefinition isEmpty ])		ifTrue: [ ^ nil.].	repo do:[ self class compiler evaluate: classDefinition]."	]] ifTrue:[UIManager inform: 'Please select database'. ^false.].collName isNil ifTrue: [ ^false.].^true.! !Object subclass: #MongoBrowserState	instanceVariableNames: 'databases collections content'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-Model'!!MongoBrowserState methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:51'!databases: anObject	databases := anObject! !!MongoBrowserState methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:51'!elementsOfCollection: collection for: protocol	^ (collection collections).! !!MongoBrowserState methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:51'!content	^ content! !!MongoBrowserState methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:51'!collections: anObject	collections := anObject! !!MongoBrowserState methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:51'!databases	^ databases! !!MongoBrowserState methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:51'!content: anObject	content := anObject! !!MongoBrowserState methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:51'!collections	^ collections! !!MongoBrowserState methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/9/2016 11:50'!collectionsIn: database 	^ (database collections).! !MongoBrowserModel subclass: #MongoCollectionDocuments	instanceVariableNames: 'id dictionary'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-Model'!!MongoCollectionDocuments methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 4/2/2017 14:08'!id: anObject	id := anObject! !!MongoCollectionDocuments methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 4/2/2017 14:08'!id	^ id! !!MongoCollectionDocuments methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 4/2/2017 14:08'!dictionary: anObject	dictionary := anObject! !!MongoCollectionDocuments methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 4/2/2017 14:08'!dictionary	^ dictionary! !!MongoCollectionDocuments methodsFor: 'accessing' stamp: 'KhrystynaMykhailiuk 4/2/2017 14:19'!printOn: aStream	aStream 		nextPutAll: id asString.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MongoCollectionDocuments class	instanceVariableNames: ''!!MongoCollectionDocuments class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 4/2/2017 15:35'!exampleObject|obj db collectionFirst dict|obj :=self new.db := Mongo default open databaseNamed: 'Baza'.collectionFirst := db collections first. dict := (collectionFirst select: Dictionary  new) first. obj id:(dict at:'_id');dictionary: dict .^obj.! !MongoBrowserModel subclass: #MongoDatabasesModel	instanceVariableNames: 'databases'	classVariableNames: ''	poolDictionaries: ''	category: 'MongoDBBrowser-Model'!!MongoDatabasesModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 5/12/2016 19:55'!getDatabasesdatabases := ( (Mongo default open databases) select: [:n|  n name~='local']).databases := databases reject: [:n|  n collections isEmpty].^databases.! !!MongoDatabasesModel methodsFor: 'as yet unclassified' stamp: 'KhrystynaMikhailuyk 5/9/2016 10:44'!initialize	self getDatabases.		! !!MongoDatabasesModel methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 10:44'!databases	^ databases! !!MongoDatabasesModel methodsFor: 'accessing' stamp: 'KhrystynaMikhailuyk 5/9/2016 10:44'!databases: anObject	databases := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MongoDatabasesModel class	instanceVariableNames: ''!!MongoDatabasesModel class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 4/1/2017 13:55'!getDatabases|databases|databases := ((Mongo default open databases) select: [:n|  n name~='local'] )asArray.databases do:[:col | col asOrderedCollection ].^databases .! !!MongoDatabasesModel class methodsFor: 'as yet unclassified' stamp: 'KhrystynaMykhailiuk 4/1/2017 15:28'!getOrderedCollectionOfDatabaseandItsCollectionNames|dbs dbsCollections dict collection|dbs := self getDatabases .dbsCollections := OrderedCollection new.dict := Dictionary new.collection := OrderedCollection new.dbs do:[:d| collection := d collections select:[:col | col name notNil].	dict at:d name put: collection.		dbsCollections add: dict.			dict := Dictionary new.	].^ dbsCollections ! !